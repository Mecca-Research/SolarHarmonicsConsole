import React, { useEffect, useMemo, useRef, useState } from "react";

/**
 * Solar Harmonics Console — Interactive N‑Body Simulator (v1.5)
 * ---------------------------------------------------------------------------
 * What's new in v1.5 (requested tweaks):
 *  • Visual sizes: planets & Sun render with more realistic relative proportions
 *    (kept orbits/physics unchanged). Each planet has a per‑planet "Visual Size"
 *    slider (0–100% extra) that persists while running and affects only rendering.
 *  • Angle control fixed: choose Absolute frame OR Prograde‑relative (default).
 *    Angle now clearly affects both Impulse and Burn.
 *  • Burn actually works: continuous Δv is applied during integration; a
 *    progress bar + remaining time shows in each planet card while burning.
 *  • Reset visual sizes: one-click reset of all per‑planet visual scales.
 *  • Minor stability: removed logical assignment (compat), safer trails init.
 *
 * Still sandbox‑safe: no network/wallet calls; pure client canvas.
 */

// ==================== Constants ====================
const G = 6.67430e-11;           // m^3 kg^-1 s^-2
const MSUN = 1.98847e30;         // kg
const AU = 1.495978707e11;       // m
const DAY = 86400;               // s
const YEAR = 365.25 * DAY;       // s
const PHI = (1 + Math.sqrt(5)) / 2;
const L_SUN = 3.828e26;          // W (solar luminosity)
const SIGMA = 5.670374419e-8;    // W m^-2 K^-4 (Stefan‑Boltzmann)
const R_EARTH = 6.371e6;         // m
const R_SUN = 6.9634e8;          // m

// Visual baselines (feel free to tweak)
const BASE_PLANET_PX = 6;        // Earth≈6px, others scale by cbrt(radius)
const BASE_SUN_PX = 18;          // Sun kept visible but not overwhelming

// ==================== Helpers ====================
const v = (x = 0, y = 0) => ({ x, y });
const add = (a, b) => v(a.x + b.x, a.y + b.y);
const sub = (a, b) => v(a.x - b.x, a.y - b.y);
const mul = (a, s) => v(a.x * s, a.y * s);
const mag = (a) => Math.hypot(a.x, a.y);
const norm = (a) => { const m = mag(a) || 1; return v(a.x / m, a.y / m); };
function circularOrbitVelocity(GM, r) { return Math.sqrt(GM / r); }

// ==================== Initial System Data ====================
const PLANET_DATA = [
  { name: "Mercury", a: 0.3871, mass: 3.3011e23, radius: 2.4397e6, color: "#c9b9a7", albedo: 0.12 },
  { name: "Venus",   a: 0.7233, mass: 4.8675e24, radius: 6.0518e6, color: "#e0c16c", albedo: 0.75 },
  { name: "Earth",   a: 1.0000, mass: 5.9724e24, radius: 6.3710e6, color: "#4da6ff", albedo: 0.30 },
  { name: "Mars",    a: 1.5237, mass: 6.4171e23, radius: 3.3895e6, color: "#ff6f50", albedo: 0.25 },
  { name: "Jupiter", a: 5.2028, mass: 1.8982e27, radius: 6.9911e7, color: "#d6a46c", albedo: 0.52 },
  { name: "Saturn",  a: 9.5388, mass: 5.6834e26, radius: 5.8232e7, color: "#f0d9a6", albedo: 0.47 },
  { name: "Uranus",  a: 19.1914, mass: 8.6810e25, radius: 2.5362e7, color: "#84dfff", albedo: 0.51 },
  { name: "Neptune", a: 30.0611, mass: 1.02413e26, radius: 2.4622e7, color: "#5d8cff", albedo: 0.41 },
  { name: "Pluto",   a: 39.482, mass: 1.309e22, radius: 1.188e6, color: "#aaa", albedo: 0.60 }, // optional
];

function makeInitialBodies(includePluto = true) {
  const sun = { name: "Sun", mass: MSUN, radius: R_SUN, pos: v(0, 0), vel: v(0, 0), color: "#ffcc00", locked: true, fluxScale: 1.0, albedo: 0.0, renderScale: 1 };
  const bodies = [sun];
  for (const p of PLANET_DATA) {
    if (!includePluto && p.name === "Pluto") continue;
    const r = p.a * AU; const speed = circularOrbitVelocity(G * sun.mass, r);
    bodies.push({ name: p.name, mass: p.mass, radius: p.radius, pos: v(r, 0), vel: v(0, speed), color: p.color, trail: [], fluxScale: 1.0, albedo: p.albedo, renderScale: 1 });
  }
  return bodies;
}

// ==================== Harmonic Shells (φ) ====================
function makePhiShells(kAU, maxAU) { const shells = []; let r = kAU, n = 0; while (r <= maxAU) { shells.push(r); n += 1; r = kAU * Math.pow(PHI, n); } return shells; }

// ==================== Belts (statistical Keplerian) ====================
// ==================== Belts (elliptical, classical rendering) ====================
// Generate particles with semi-major axis a∈[innerAU, outerAU], eccentricity e∈[0,eccMax].
// We advance the true anomaly with the mean motion n≈sqrt(GM/a^3) and render with
// r(θ) = a(1-e^2) / (1 + e cos θ). This keeps the radial envelope correct and
// avoids bleeding into forbidden regions (e.g., Neptune's orbit) if we pick
// appropriate inner bounds.
function makeEllipticalRingParticles(count, innerAU, outerAU, eccMax = 0.1) {
  const arr = [];
  for (let i = 0; i < count; i++) {
    const a = innerAU + Math.random() * (outerAU - innerAU);
    const e = Math.min(Math.max(Math.random() * eccMax, 0), 0.99);
    const theta = Math.random() * Math.PI * 2; // true anomaly
    const n = Math.sqrt((G * MSUN) / Math.pow(a * AU, 3)); // mean motion
    arr.push({ a, e, theta, n });
  }
  return arr;
}

function makeKuiperParticles(count) {
  // Classical (non-resonant) belt ~42–48 AU, low-e; intentionally keep inside edge
  // well outside Neptune (30 AU) so it doesn't intrude visually.
  return makeEllipticalRingParticles(count, 42, 48, 0.10);
}

// ==================== N‑body (Velocity‑Verlet) ====================
function computeAccelerations(bodies) {
  const acc = bodies.map(() => v(0, 0));
  for (let i = 0; i < bodies.length; i++) {
    if (bodies[i].locked) continue;
    for (let j = 0; j < bodies.length; j++) { if (i === j) continue; const rij = sub(bodies[j].pos, bodies[i].pos); const r = mag(rij) + 1e-9; const a = (G * bodies[j].mass) / (r * r * r); acc[i] = add(acc[i], mul(rij, a)); }
  }
  return acc;
}
function stepVerlet(bodies, dt) {
  const acc0 = computeAccelerations(bodies);
  for (let i = 0; i < bodies.length; i++) { if (bodies[i].locked) continue; bodies[i].pos = add(bodies[i].pos, add(mul(bodies[i].vel, dt), mul(acc0[i], 0.5 * dt * dt))); }
  const acc1 = computeAccelerations(bodies);
  for (let i = 0; i < bodies.length; i++) { if (bodies[i].locked) continue; bodies[i].vel = add(bodies[i].vel, mul(add(acc0[i], acc1[i]), 0.5 * dt)); }
}

// ==================== Rendering helpers ====================
function worldToScreen(p, cx, cy, scaleAUperPx) { return v(cx + (p.x / AU) / scaleAUperPx, cy - (p.y / AU) / scaleAUperPx); }
function drawCircle(ctx, x, y, r, color) { ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fillStyle = color; ctx.fill(); }
function drawRing(ctx, x, y, r, color, width = 1) { ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.strokeStyle = color; ctx.lineWidth = width; ctx.stroke(); }

// Visual radius: proportional across bodies but exaggerated for usability
function renderRadiusPx(body) {
  if (body.name === "Sun") return Math.max(10, BASE_SUN_PX * (body.renderScale || 1));
  const factor = Math.cbrt((body.radius || R_EARTH) / R_EARTH); // relative to Earth
  const base = BASE_PLANET_PX * factor;
  return Math.max(2, base * (body.renderScale || 1));
}

// ==================== Thermals (Insolation → Temperature) ====================
function solarFluxAtR(r_m) { return L_SUN / (4 * Math.PI * r_m * r_m); }             // W/m^2 on sphere
function equilibriumTempK(r_m, albedo = 0.3, fluxScale = 1.0) {
  // T = [(S*(1-A)*fluxScale) / (4σ)]^(1/4)  (no greenhouse)
  const S = solarFluxAtR(r_m) * fluxScale; return Math.pow((S * (1 - albedo)) / (4 * SIGMA), 0.25);
}

// ==================== Tests / Diagnostics ====================
function Diagnostics({ bodies }) {
  let KE = 0, PE = 0;
  for (let i = 0; i < bodies.length; i++) { const b = bodies[i]; KE += 0.5 * b.mass * (b.vel.x ** 2 + b.vel.y ** 2); for (let j = i + 1; j < bodies.length; j++) { const r = mag(sub(b.pos, bodies[j].pos)) + 1e-9; PE += -G * b.mass * bodies[j].mass / r; } }
  const E = KE + PE; const fmt = (x) => (Math.abs(x) >= 1 ? x.toExponential(3) : x.toPrecision(3));
  return (
    <div className="text-xs grid grid-cols-2 gap-y-1">
      <div className="opacity-70">Bodies</div><div>{bodies.length}</div>
      <div className="opacity-70">Kinetic</div><div>{fmt(KE)} J</div>
      <div className="opacity-70">Potential</div><div>{fmt(PE)} J</div>
      <div className="opacity-70">Total</div><div>{fmt(E)} J</div>
    </div>
  );
}

function TestsPanel() {
  const [out, setOut] = useState([]); const push = (name, ok, msg = "") => setOut((xs) => [...xs, { name, ok, msg }]);
  const run = () => {
    setOut([]);
    try {
      const GM = G * MSUN; const v1 = circularOrbitVelocity(GM, AU); const ok1 = Math.abs(v1 - 29780) < 1500; push("orbital speed @1AU ~29.8 km/s", ok1, `got ${v1.toFixed(0)} m/s`);
      const shells = makePhiShells(0.2, 10); let mono = true; for (let i = 1; i < shells.length; i++) if (!(shells[i] > shells[i-1])) mono = false; push("φ shells increasing", mono, shells.slice(0,5).map(x=>x.toFixed(3)).join(","));
      const belt = makeEllipticalRingParticles(250, 2.1, 3.3, 0.2); const ok3 = belt.length === 250 && belt.every(p => p.n > 0); push("belt count & n>0", ok3, `n=${belt.length}`);
      const earthR = AU; const Teq = equilibriumTempK(earthR, 0.3, 1.0); push("Earth Teq ~255K", Math.abs(Teq - 255) < 20, `got ${Teq.toFixed(1)} K`);
    } catch (e) { push("tests crashed", false, String(e?.message||e)); }
  };
  return (
    <div className="rounded-2xl border border-neutral-800 p-2 bg-neutral-900/60">
      <div className="flex items-center justify-between mb-1">
        <div className="text-sm font-semibold">Tests</div>
        <button onClick={run} className="px-2 py-1 rounded bg-indigo-600 hover:bg-indigo-500 text-xs">Run</button>
      </div>
      <ul className="text-[11px] space-y-1 max-h-40 overflow-auto pr-1">
        {out.map((t,i)=> (
          <li key={i} className={"flex items-start gap-2 "+(t.ok?"text-emerald-400":"text-rose-400")}> <span>{t.ok?"✓":"✗"}</span><span className="font-semibold">{t.name}</span><span className="opacity-70"> — {t.msg}</span></li>
        ))}
      </ul>
    </div>
  );
}

// ==================== Main Component ====================
export default function SolarHarmonicsConsole() {
  // Simulation state
  const [includePluto, setIncludePluto] = useState(true);
  const [bodies, setBodies] = useState(() => makeInitialBodies(true));
  const [running, setRunning] = useState(true);
  const [timeScale, setTimeScale] = useState(86400); // sec / sec
  const [dt, setDt] = useState(1800);
  const [zoomAUPer100px, setZoomAUPer100px] = useState(1.2);
  const [showTrails, setShowTrails] = useState(true);
  const [showBelts, setShowBelts] = useState(true);
  const [showShells, setShowShells] = useState(true);
  const [shellK, setShellK] = useState(0.18);
  const [beltDensity, setBeltDensity] = useState(700);
  const [kuiperDensity, setKuiperDensity] = useState(700);
  const [lockSun, setLockSun] = useState(true);
  const [autoFit, setAutoFit] = useState(true);

  // Δv control state
  const [dvMode, setDvMode] = useState("impulse"); // "impulse" | "burn"
  const [angleMode, setAngleMode] = useState("prograde"); // "absolute" | "prograde"
  const [burnDuration, setBurnDuration] = useState(12 * 3600); // seconds

  // Belts
  const belt = useMemo(() => makeEllipticalRingParticles(beltDensity, 2.1, 3.3, 0.2), [beltDensity]);
  const kuiper = useMemo(() => makeKuiperParticles(kuiperDensity), [kuiperDensity]);

  // Canvas & RAF
  const canvasRef = useRef(null); const rafRef = useRef(null);

  // Recreate system on Pluto toggle
  useEffect(() => { setBodies(makeInitialBodies(includePluto)); }, [includePluto]);

  // Fit helper
  function computeFitZoomAUPer100px(widthPx, heightPx) {
    const maxR_AU = Math.max(...bodies.map(b => mag(b.pos) / AU), 0.5) * 1.1;
    const halfMinPx = Math.min(widthPx, heightPx) / 2;
    const AUperPx = maxR_AU / halfMinPx; // AU per px for full fit
    return AUperPx * 100; // AU per 100px setting
  }

  // Simulation + render loop
  useEffect(() => {
    const canvas = canvasRef.current; if (!canvas) return; const ctx = canvas.getContext("2d"); if (!ctx) return;

    function resize() {
      const w = canvas.clientWidth, h = canvas.clientHeight; canvas.width = w; canvas.height = h;
      if (autoFit) { const z = computeFitZoomAUPer100px(w, h); setZoomAUPer100px(z); }
    }
    resize();
    let ro; try { ro = new ResizeObserver(resize); ro.observe(canvas); } catch { window.addEventListener("resize", resize); }

    let last = performance.now();
    const frame = (now) => {
      const elapsed = Math.max(0, now - last) / 1000; last = now;

      if (running) {
        // Apply burns stored on bodies: incremental Δv across simulated time slice
        const dtSimFrame = elapsed * timeScale;
        for (const b of bodies) {
          const burn = b._burn; if (!burn || burn.remaining <= 0) continue;
          const chunk = Math.min(burn.remaining, dtSimFrame);
          if (chunk > 0) {
            const dvStep = burn.dvTotal * (chunk / burn.duration);
            // angle source: absolute frame or prograde‑relative
            const base = (angleMode === "prograde") ? norm(b.vel) : v(1, 0);
            const ang = burn.angleRad; // rotate base by ang
            const cosA = Math.cos(ang), sinA = Math.sin(ang);
            const dir = v(base.x * cosA - base.y * sinA, base.x * sinA + base.y * cosA);
            b.vel = add(b.vel, mul(dir, dvStep));
            burn.remaining -= chunk; if (burn.remaining <= 0) delete b._burn;
          }
        }

        // Integrate with sub‑steps for stability
        let simT = dtSimFrame; const nSteps = Math.max(1, Math.min(300, Math.ceil(simT / dt))); const h = simT / nSteps; for (let k = 0; k < nSteps; k++) stepVerlet(bodies, h);

        // Trails (compat: no ||=)
        if (showTrails) { for (const b of bodies) { if (!b.trail) b.trail = []; b.trail.push({ x: b.pos.x, y: b.pos.y }); if (b.trail.length > 800) b.trail.shift(); } } else { for (const b of bodies) b.trail = []; }
      }

      // Render
      const w = canvas.clientWidth, hpx = canvas.clientHeight; const cx = w / 2, cy = hpx / 2; const scaleAUperPx = zoomAUPer100px / 100;
      ctx.clearRect(0, 0, w, hpx);

      // Harmonic shells
      if (showShells) { const shellsAU = makePhiShells(shellK, 60); for (const rAU of shellsAU) drawRing(ctx, cx, cy, (rAU / scaleAUperPx), "rgba(150,200,255,0.25)", 1); }

      // Belts
      if (showBelts) {
        // Asteroid belt
        ctx.fillStyle = "rgba(180,180,180,0.8)";
        for (const p of belt) {
          if (running) p.theta += p.n * (elapsed * timeScale);
          const rAU = (p.a * (1 - p.e * p.e)) / (1 + p.e * Math.cos(p.theta));
          const x = cx + (rAU / scaleAUperPx) * Math.cos(p.theta);
          const y = cy + (rAU / scaleAUperPx) * Math.sin(p.theta);
          ctx.fillRect(x, y, 1.2, 1.2);
        }
        // Kuiper belt (classical)
        ctx.fillStyle = "rgba(120,200,255,0.8)";
        for (const p of kuiper) {
          if (running) p.theta += p.n * (elapsed * timeScale);
          const rAU = (p.a * (1 - p.e * p.e)) / (1 + p.e * Math.cos(p.theta));
          const x = cx + (rAU / scaleAUperPx) * Math.cos(p.theta);
          const y = cy + (rAU / scaleAUperPx) * Math.sin(p.theta);
          ctx.fillRect(x, y, 1.0, 1.0);
        }
      }

      // Bodies
      for (const b of bodies) {
        if (showTrails && b.trail && b.trail.length > 1) { ctx.beginPath(); for (let i = 0; i < b.trail.length; i++) { const p = worldToScreen(b.trail[i], cx, cy, scaleAUperPx); if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); } ctx.strokeStyle = `${b.color}80`; ctx.lineWidth = 1; ctx.stroke(); }
        const sp = worldToScreen(b.pos, cx, cy, scaleAUperPx);
        const rpx = renderRadiusPx(b);
        drawCircle(ctx, sp.x, sp.y, rpx, b.color);
      }

      rafRef.current = requestAnimationFrame(frame);
    };

    rafRef.current = requestAnimationFrame(frame);
    return () => { if (rafRef.current) cancelAnimationFrame(rafRef.current); try { ro && ro.disconnect && ro.disconnect(); } catch {} window.removeEventListener("resize", resize); };
  }, [bodies, running, timeScale, dt, zoomAUPer100px, showTrails, showBelts, showShells, shellK, belt, kuiper, autoFit, angleMode]);

  // ---------- Controls & helpers ----------
  const resetSystem = () => setBodies(makeInitialBodies(includePluto));

  // Visual size controls (per‑planet). Stores in b.renderScale (1..2)
  const setVisualScale = (name, pct0to100) => setBodies((bs) => bs.map((b) => b.name === name ? ({ ...b, renderScale: 1 + Math.max(0, Math.min(100, pct0to100)) / 100 }) : b));
  const incVisualScale = (name, deltaPct) => setBodies((bs) => bs.map((b) => {
    if (b.name !== name) return b; const cur = (b.renderScale || 1); const next = Math.max(1, Math.min(2, cur + deltaPct / 100)); return { ...b, renderScale: next };
  }));
  const resetVisualSizes = () => setBodies((bs) => bs.map((b) => ({ ...b, renderScale: 1 })));

  function toAngleRad(body, angleDeg) {
    const ang = (Number(angleDeg) || 0) * Math.PI / 180;
    if (angleMode === "absolute") return ang; // 0° = +x
    // prograde‑relative: rotate unit velocity by entered angle
    const t = norm(body.vel); // if nearly zero, fallback to +x
    const base = (mag(body.vel) < 1e-6) ? v(1,0) : t;
    return Math.atan2(base.y, base.x) + ang;
  }

  function queueBurn(name, dvTotal, angleDeg, durationSec) {
    const duration = Math.max(1, Number(durationSec) || 0);
    setBodies((bs) => bs.map((b) => {
      if (b.name !== name) return b;
      const angleRad = toAngleRad(b, angleDeg);
      return { ...b, _burn: { remaining: duration, duration, angleRad, dvTotal: Number(dvTotal)||0 } };
    }));
  }

  const applyImpulse = (name, dvMag_mps, angleDeg) => setBodies((bs) => bs.map((b) => {
    if (b.name !== name) return b; const angleRad = toAngleRad(b, angleDeg); const dv = v(Math.cos(angleRad) * (Number(dvMag_mps)||0), Math.sin(angleRad) * (Number(dvMag_mps)||0)); return { ...b, vel: add(b.vel, dv) };
  }));

  const presetNudgeMars = () => (dvMode === "impulse" ? applyImpulse("Mars", 50, 0) : queueBurn("Mars", 100, 0, 7 * 24 * 3600));
  const presetCoolVenusShade = () => setBodies((bs) => bs.map((b) => b.name === "Venus" ? { ...b, fluxScale: Math.max(0.2, (b.fluxScale ?? 1) * 0.7), albedo: Math.min(0.95, (b.albedo ?? 0.75) + 0.05) } : b));

  // Diagnostics list per planet (r, flux, temp)
  const thermoRows = useMemo(() => {
    return bodies.filter(b => b.name !== "Sun").map(b => {
      const r_m = mag(b.pos); const flux = solarFluxAtR(r_m) * (b.fluxScale ?? 1); const T = equilibriumTempK(r_m, b.albedo ?? 0.3, b.fluxScale ?? 1);
      return { name: b.name, r_AU: (r_m / AU).toFixed(2), flux: flux.toFixed(0), T: T.toFixed(1) };
    });
  }, [bodies]);

  const planetList = bodies.filter((b) => b.name !== "Sun");

  return (
    <div className="w-full h-full grid grid-cols-12 gap-2 p-2 bg-neutral-950 text-neutral-100">
      {/* Canvas: more space (col-span-10) */}
      <div className="col-span-10 rounded-2xl overflow-hidden border border-neutral-800">
        <canvas ref={canvasRef} className="w-full h-[88vh] bg-black" />
        <div className="flex flex-wrap items-center gap-2 p-2 border-t border-neutral-800 bg-neutral-900/60 text-xs">
          <button className="px-2 py-1 rounded bg-emerald-600 hover:bg-emerald-500" onClick={() => setRunning((r) => !r)}>{running ? "Pause" : "Run"}</button>
          <button className="px-2 py-1 rounded bg-neutral-700 hover:bg-neutral-600" onClick={() => setAutoFit(true)}>Fit</button>
          <label>Speed: {timeScale.toExponential(2)} s/s</label>
          <input type="range" min={3600} max={3600 * 24 * 365 * 5} step={3600} value={timeScale} onChange={(e) => setTimeScale(parseFloat(e.target.value))} className="w-56" />
          <label>dt: {dt}s</label>
          <input type="range" min={300} max={DAY * 3} step={300} value={dt} onChange={(e) => setDt(parseFloat(e.target.value))} className="w-40" />
          <label>Zoom (AU/100px): {zoomAUPer100px.toFixed(2)}</label>
          <input type="range" min={0.1} max={8} step={0.05} value={zoomAUPer100px} onChange={(e) => { setAutoFit(false); setZoomAUPer100px(parseFloat(e.target.value)); }} className="w-48" />
          <label>Angle:</label>
          <select className="bg-neutral-800 rounded px-2 py-1" value={angleMode} onChange={(e)=>setAngleMode(e.target.value)}>
            <option value="prograde">Prograde‑relative</option>
            <option value="absolute">Absolute (0° = +x)</option>
          </select>
        </div>
      </div>

      {/* Right Console: compact (col-span-2) */}
      <div className="col-span-2 flex flex-col gap-2 text-[12px]">
        <div className="rounded-2xl border border-neutral-800 p-2 bg-neutral-900/60">
          <div className="font-semibold mb-1">Display</div>
          <div className="flex flex-col gap-1">
            <label className="flex items-center gap-2"><input type="checkbox" checked={showTrails} onChange={(e) => setShowTrails(e.target.checked)} />Trails</label>
            <label className="flex items-center gap-2"><input type="checkbox" checked={showBelts} onChange={(e) => setShowBelts(e.target.checked)} />Belts</label>
            <label className="flex items-center gap-2"><input type="checkbox" checked={showShells} onChange={(e) => setShowShells(e.target.checked)} />φ Shells</label>
            <label className="flex items-center gap-2"><input type="checkbox" checked={includePluto} onChange={(e) => setIncludePluto(e.target.checked)} />Pluto</label>
            <label className="flex items-center gap-2"><input type="checkbox" checked={lockSun} onChange={(e) => { setLockSun(e.target.checked); setBodies((bs) => bs.map((b) => b.name === "Sun" ? { ...b, locked: e.target.checked } : b)); }} />Lock Sun</label>
            <label className="flex items-center gap-2"><input type="checkbox" checked={autoFit} onChange={(e) => setAutoFit(e.target.checked)} />Auto‑fit</label>
          </div>
          <div className="mt-2">
            <label>φ base k (AU): {shellK.toFixed(2)}</label>
            <input type="range" min={0.05} max={1.0} step={0.01} value={shellK} onChange={(e) => setShellK(parseFloat(e.target.value))} className="w-full" />
          </div>
          <div className="mt-2 grid grid-cols-2 gap-1 items-center">
            <label>Asteroids</label>
            <input type="range" min={0} max={4000} value={beltDensity} onChange={(e) => setBeltDensity(parseInt(e.target.value))} />
            <label>Kuiper</label>
            <input type="range" min={0} max={4000} value={kuiperDensity} onChange={(e) => setKuiperDensity(parseInt(e.target.value))} />
          </div>
        </div>

        <div className="rounded-2xl border border-neutral-800 p-2 bg-neutral-900/60">
          <div className="font-semibold mb-1">Δv / Terraform</div>
          <div className="flex items-center gap-2 mb-1">
            <select className="bg-neutral-800 rounded px-2 py-1" value={dvMode} onChange={(e) => setDvMode(e.target.value)}>
              <option value="impulse">Impulse</option>
              <option value="burn">Burn</option>
            </select>
            {dvMode === "burn" && (<><label>Duration (s)</label><input className="bg-neutral-800 rounded px-2 py-1 w-24" type="number" value={burnDuration} onChange={(e) => setBurnDuration(parseInt(e.target.value||"0"))} /></>)}
          </div>
          {planetList.map((p) => {
            const burn = p._burn; const progress = burn ? (1 - burn.remaining / burn.duration) : 0;
            return (
            <div key={p.name} className="mb-2 border-b border-neutral-800 pb-2">
              <div className="flex items-center justify-between">
                <div className="font-semibold" style={{ color: p.color }}>{p.name}</div>
                <div className="flex items-center gap-2">
                  <label className="opacity-70">Visual Size</label>
                  <input className="w-28" type="range" min={0} max={100} step={1} value={Math.round(((p.renderScale||1)-1)*100)} onChange={(e)=>setVisualScale(p.name, parseInt(e.target.value))} />
                  <button className="px-2 py-0.5 rounded bg-neutral-800 hover:bg-neutral-700" onClick={()=>incVisualScale(p.name, +10)}>+10%</button>
                </div>
              </div>
              {burn && (
                <div className="mt-1">
                  <div className="h-2 bg-neutral-800 rounded overflow-hidden">
                    <div className="h-full bg-emerald-600" style={{ width: `${(progress*100).toFixed(1)}%` }} />
                  </div>
                  <div className="text-[10px] opacity-80 mt-0.5">Burn: {(burn.duration-burn.remaining|0)} / {burn.duration|0}s • Δv={burn.dvTotal} m/s • angle={(burn.angleRad*180/Math.PI).toFixed(0)}°</div>
                </div>
              )}
              <div className="mt-1 grid grid-cols-3 gap-1 items-center">
                <label>Δv (m/s)</label>
                <input id={`dv-${p.name}`} className="col-span-2 px-2 py-1 bg-neutral-800 rounded" type="number" defaultValue={30} />
                <label>Angle (°)</label>
                <input id={`ang-${p.name}`} className="col-span-2 px-2 py-1 bg-neutral-800 rounded" type="number" defaultValue={0} />
                <button className="col-span-3 mt-1 px-2 py-1 rounded bg-emerald-600 hover:bg-emerald-500" onClick={() => {
                  const dv = parseFloat((document.getElementById(`dv-${p.name}`))?.value || "0");
                  const ang = parseFloat((document.getElementById(`ang-${p.name}`))?.value || "0");
                  if (!isFinite(dv) || !isFinite(ang)) return;
                  if (dvMode === "impulse") { applyImpulse(p.name, dv, ang); }
                  else { queueBurn(p.name, dv, ang, burnDuration); }
                }}>Apply</button>
              </div>
            </div>
          );})}
          <div className="flex flex-wrap gap-1">
            <button className="px-2 py-1 rounded bg-sky-700 hover:bg-sky-600" onClick={()=>applyImpulse("Mars", 50, 0)}>Preset: Nudge Mars</button>
            <button className="px-2 py-1 rounded bg-amber-700 hover:bg-amber-600" onClick={presetCoolVenusShade}>Preset: Cool Venus</button>
            <button className="px-2 py-1 rounded bg-neutral-700 hover:bg-neutral-600" onClick={resetVisualSizes}>Reset Visual Sizes</button>
            <button className="px-2 py-1 rounded bg-neutral-700 hover:bg-neutral-600" onClick={resetSystem}>Reset System</button>
          </div>
        </div>

        <div className="rounded-2xl border border-neutral-800 p-2 bg-neutral-900/60">
          <div className="font-semibold mb-1">Thermals</div>
          <div className="text-[11px] max-h-40 overflow-auto">
            {thermoRows.map(r => (
              <div key={r.name} className="flex justify-between gap-2">
                <span className="opacity-80 w-14">{r.name}</span>
                <span className="w-10">{r.r_AU} AU</span>
                <span className="w-14">{r.flux} W/m²</span>
                <span className="w-12">{r.T} K</span>
              </div>
            ))}
          </div>
        </div>

        <div className="rounded-2xl border border-neutral-800 p-2 bg-neutral-900/60">
          <div className="font-semibold mb-1">Diagnostics & Tests</div>
          <Diagnostics bodies={bodies} />
          <div className="mt-2"><TestsPanel /></div>
        </div>
      </div>
    </div>
  );
}
